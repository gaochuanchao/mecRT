//
//  Project: mecRT â€“ Mobile Edge Computing Simulator for Real-Time Applications
//  File:    NodePacketController.cc / NodePacketController.h
//
//  Description:
//    This file implements a simple module that routes packets from the gnb to the user device.
//    When data is routing within the backhaul network, the data is first sent to this module of a gnb, then
//    it is forwarded to the user device by this module.
//
//  Author:  Gao Chuanchao (Nanyang Technological University)
//  Date:    2025-09-01
//
//  License: Academic Public License -- NOT FOR COMMERCIAL USE
//

#include "mecrt/coreNetwork/NodePacketController.h"
#include <inet/common/packet/printer/PacketPrinter.h>
#include <inet/networklayer/ipv4/Ipv4Header_m.h>
#include "inet/networklayer/common/L3AddressTag_m.h"
#include <inet/common/TimeTag_m.h>

#include "mecrt/packets/apps/Grant2Veh.h"
#include "mecrt/packets/apps/Grant2Rsu_m.h"
#include "mecrt/packets/apps/ServiceStatus_m.h"


Define_Module(NodePacketController);

using namespace omnetpp;
using namespace inet;

NodePacketController::NodePacketController()
{
    localPort_ = -1;
    nodeInfo_ = nullptr;
    enableInitDebug_ = false;

    srvReqsBuffer_.clear();
}

NodePacketController::~NodePacketController()
{
    if (enableInitDebug_)
        std::cout << "NodePacketController::~NodePacketController - destroying NodePacketController module\n";


    if (enableInitDebug_)
        std::cout << "NodePacketController::~NodePacketController - destroying NodePacketController module done!\n";
}


void NodePacketController::initialize(int stage)
{
    cSimpleModule::initialize(stage);

    if (stage == INITSTAGE_LOCAL)
    {
        EV << "NodePacketController::initialize - local init stage" << endl;

        if (getSystemModule()->hasPar("enableInitDebug"))
            enableInitDebug_ = getSystemModule()->par("enableInitDebug").boolValue();
        if (enableInitDebug_)
            std::cout << "NodePacketController::initialize - INITSTAGE_LOCAL begin" << endl;

        localPort_ = MEC_NPC_PORT; // default(37);

        if (enableInitDebug_)
            std::cout << "NodePacketController::initialize - INITSTAGE_LOCAL end" << endl;
    }
    else if (stage == inet::INITSTAGE_APPLICATION_LAYER)
    {
        if (enableInitDebug_)
            std::cout << "NodePacketController::initialize - INITSTAGE_APPLICATION_LAYER begin" << endl;

        // transport layer access
        socket_.setOutputGate(gate("socketOut"));
        socket_.bind(localPort_);
        socketId_ = socket_.getSocketId();
        
        try {
            nodeInfo_ = getModuleFromPar<NodeInfo>(par("nodeInfoModulePath"), this);
            nodeInfo_->setNpcSocketId(socketId_);
            nodeInfo_->setNpc(this);
        } catch (cException &e) {
            throw cRuntimeError("NodePacketController:initialize - cannot find nodeInfo module\n");
        }

        WATCH_PTR(nodeInfo_);
        WATCH(localPort_);
        WATCH(socketId_);
        WATCH_MAP(srvReqsBuffer_);

        if (enableInitDebug_)
            std::cout << "NodePacketController::initialize - INITSTAGE_APPLICATION_LAYER end" << endl;
    }
}


void NodePacketController::handleMessage(cMessage *msg)
{
    // self message
    if (msg->isSelfMessage())
    {
        // do nothing for now
        EV << "NodePacketController::handleMessage - received self-message: " << msg->getName() << endl;
    }
    else
    {
        EV << "NodePacketController::handleMessage - message from udp layer" << endl;
        Packet *pkt = check_and_cast<Packet *>(msg);
        PacketPrinter printer; // turns packets into human readable strings
        printer.printPacket(EV, pkt); // print to standard output

        if (strcmp(pkt->getName(), "SrvReq") == 0)  // service request packet from the UE
        {
            handleServiceRequest(pkt);
            delete pkt;
            pkt = nullptr;
            return;
        }
        else if (strcmp(pkt->getName(), "RsuFD") == 0)
        {
            // in our current design, if the RsuED is generated by the local NIC, it will be send to the server module directly
            // if it is generated by the remote NIC (e.g., from another gnb), it will be sent to its local server first, which then
            // forwards the packet to the NodePacketController module of the global scheduler
            // then the NodePacketController module will forward it to the global scheduler
            if (nodeInfo_->getIsGlobalScheduler())
            {
                // if we are the global scheduler, forward the vehicle grant packet to the local scheduler
                EV << NOW << " NodePacketController::handleFromUdp - we are the global scheduler, forward the vehicle grant packet to the local scheduler." << endl;
                pkt->clearTags(); // clear all tags first
                pkt->addTagIfAbsent<SocketInd>()->setSocketId(nodeInfo_->getLocalSchedulerSocketId());
                send(pkt, "socketOut");
            }
            else
            {
                // if we are not the global scheduler, just drop the vehicle grant packet
                EV << NOW << " NodePacketController::handleFromUdp - we are not the global scheduler, drop the vehicle grant packet." << endl;
                delete pkt;
                pkt = nullptr;
            }
            return;
        }
        else if (strcmp(pkt->getName(), "SrvGrant") == 0) // service grant packet from the global scheduler
        {
            handleServiceGrant(pkt);
            return;
        }
        else if (strcmp(pkt->getName(), "SrvFD") == 0) // service feedback packet from the local scheduler
        {
            handleServiceFeedback(pkt);
            return;
        }
        else if (strcmp(pkt->getName(), "NicGrant") == 0) // NIC grant packet from the processing server
        {
            handleOffloadingNicGrant(pkt);
            return;
        }
        else
        {
            EV << NOW << " NodePacketController::handleFromUdp - Unknown packet type " << pkt->getName() << ", drop it." << endl;
            delete pkt;
            pkt = nullptr;
            return;
        }
    }
}


void NodePacketController::handleServiceFeedback(inet::Packet *packet)
{
    auto srvStatus = packet->peekAtFront<ServiceStatus>();
    AppId appId = srvStatus->getAppId();
    EV << NOW << " NodePacketController::handleFromUdp - Received a service feedback packet for app " << appId << endl;

    // check if we are the global scheduler
    if (nodeInfo_->getIsGlobalScheduler())
    {
        EV << NOW << " NodePacketController::handleFromUdp - we are the global scheduler, forward the service feedback packet to the global scheduler." << endl;
        packet->addTagIfAbsent<SocketInd>()->setSocketId(nodeInfo_->getLocalSchedulerSocketId());
        send(packet, "socketOut");
        return;
    }
    else
    {
        EV << NOW << " NodePacketController::handleFromUdp - we are not the global scheduler, drop the service feedback packet." << endl;
        delete packet;
        packet = nullptr;
        return;
    }
}


void NodePacketController::handleServiceRequest(Packet *pkt)
{
    /***
     * When receive a service request packet from the UE, create two copies of the packet:
     * 1) one is sent to the global scheduler (if it exists)
     * 2) the other is sent to the local scheduler
     * if local scheduler is voted as the global scheduler, then only one copy is sent to the local scheduler
     */
    auto srvReq = pkt->peekAtFront<VecRequest>();
    AppId appId = srvReq->getAppId();
    EV << NOW << " NodePacketController::handleServiceRequest - Received a service request packet for app " << appId << endl;

    // check if the service request for this app has been buffered
    if (srvReqsBuffer_.find(appId) != srvReqsBuffer_.end())
    {
        EV << NOW << " NodePacketController::handleServiceRequest - Service request for app " << appId 
            << " has been buffered, ignore the new request." << endl;
        return;
    }

    Ptr<VecRequest> srvReqCopy = makeShared<VecRequest>(*srvReq);
    int ueAddr = srvReq->getUeIpAddress();
    if (ueAddr == 0)
    {
        EV << NOW << " NodePacketController::handleServiceRequest - fill in the UE IP address in the service request packet." << endl;
        // get ipv4 address of the ue from the VecRequest packet tag
        auto ueIpAddress = pkt->getTag<L3AddressInd>()->getSrcAddress().toIpv4();
        srvReqCopy->setUeIpAddress(ueIpAddress.getInt());
        // if want to get the src port, use pkt->getTag<L4PortInd>()->getSrcPort()
    }
    srvReqsBuffer_[appId] = srvReqCopy; // buffer the request in case the global scheduler recovers later
    
    // create a copy of the service request packet for the local scheduler
    EV << NOW << " NodePacketController::handleServiceRequest - send a copy of the service request packet to the local scheduler." << endl;
    Packet* packetToLocal = new Packet("SrvReq");
    packetToLocal->insertAtBack(srvReqCopy);
    // bypass the udp socket, send the packet to the local application
    packetToLocal->addTagIfAbsent<SocketInd>()->setSocketId(nodeInfo_->getLocalSchedulerSocketId());
    send(packetToLocal, "socketOut");

    // broadcast the service request to all neighbors
    if (!nodeInfo_->getNeighborAddrs().empty())
    {
        EV << NOW << " NodePacketController::handleServiceRequest - broadcast a copy of the service request packet to all neighbor nodes." << endl;
        if (ueAddr == 0)    // this is received from UE, broadcast to all neighbors
        {
            for (const auto& pair : nodeInfo_->getNeighborAddrs())
            {   
                // check if the interface is active
                NetworkInterface* ni = pair.second;
                if (!ni || !ni->isUp() || ni->isWireless())
                    continue;
                
                Packet* packetToNeighbor = new Packet("SrvReq");
                packetToNeighbor->insertAtBack(srvReqsBuffer_[appId]);
                socket_.sendTo(packetToNeighbor, Ipv4Address(pair.first), MEC_NPC_PORT);
                broadcastedSrvReqs_[appId].insert(pair.first);
            }
        }
        else
        {
            // this is received from other gNB, only broadcast to neighbors that have not received it yet
            int na = pkt->getTag<L3AddressInd>()->getSrcAddress().toIpv4().getInt();
            for (const auto& pair : nodeInfo_->getNeighborAddrs())
            {
                if (na == pair.first)
                {
                    broadcastedSrvReqs_[appId].insert(pair.first);
                    continue; // do not send back to the sender
                }

                if (broadcastedSrvReqs_[appId].find(pair.first) != broadcastedSrvReqs_[appId].end())
                    continue; // already broadcasted to this neighbor

                // check if the neighbor address is reachable
                NetworkInterface* ni = pair.second;
                if (!ni || !ni->isUp() || ni->isWireless())
                    continue;

                Packet* packetToNeighbor = new Packet("SrvReq");
                packetToNeighbor->insertAtBack(srvReqsBuffer_[appId]);
                socket_.sendTo(packetToNeighbor, Ipv4Address(pair.first), MEC_NPC_PORT);
                broadcastedSrvReqs_[appId].insert(pair.first);
            }
        }
    }

    // send a copy to the global scheduler (if it exists)
    // if (!nodeInfo_->getIsGlobalScheduler() && !nodeInfo_->getGlobalSchedulerAddr().isUnspecified())
    // {
    //     EV << NOW << " NodePacketController::handleServiceRequest - send a copy of the service request packet to the global scheduler." << endl;
    //     Packet* packetToGlobal = new Packet("SrvReq");
    //     packetToGlobal->insertAtBack(srvReqsBuffer_[appId]);
    //     socket_.sendTo(packetToGlobal, nodeInfo_->getGlobalSchedulerAddr(), MEC_NPC_PORT);
    // }
}


void NodePacketController::handleServiceGrant(Packet *pkt)
{
    auto srvGrant = pkt->peekAtFront<Grant2Rsu>();
    AppId appId = srvGrant->getAppId();
    EV << NOW << " NodePacketController::handleFromUdp - Received a service grant packet for app " << appId << endl;

    // first check if the processing RSU is the local RSU
    MacNodeId processGnbId = srvGrant->getProcessGnbId();
    if (processGnbId == nodeInfo_->getNodeId() && !nodeInfo_->getIsGlobalScheduler())
    {
        EV << NOW << " NodePacketController::handleFromUdp - the processing RSU is the local RSU, send to local processing module" << endl;
        pkt->clearTags(); // clear all tags first
        pkt->addTagIfAbsent<SocketInd>()->setSocketId(nodeInfo_->getServerSocketId());
        send(pkt, "socketOut");
        return;
    }
    else
    {
        EV << NOW << " NodePacketController::handleFromUdp - the processing RSU is not the local RSU, service initialization fails!" << endl;

        Packet* packet = new Packet("SrvFD");
        auto srvStatus = makeShared<ServiceStatus>();
        srvStatus->setSuccess(false);
        srvStatus->setAppId(appId);
        srvStatus->setProcessGnbId(processGnbId);
        srvStatus->setOffloadGnbId(srvGrant->getOffloadGnbId());
        srvStatus->setProcessGnbCuUpdateTime(0);
        srvStatus->setOffloadGnbRbUpdateTime(0);
        packet->insertAtFront(srvStatus);
        socket_.sendTo(packet, nodeInfo_->getGlobalSchedulerAddr(), MEC_NPC_PORT);

        delete pkt;
        pkt = nullptr;
        return;
    }
}


void NodePacketController::handleOffloadingNicGrant(Packet *pkt)
{
    auto nicGrant = pkt->peekAtFront<Grant2Veh>();
    AppId appId = nicGrant->getAppId();
    EV << NOW << " NodePacketController::handleFromUdp - Received a NIC grant packet for app " << appId << endl;

    // first check if we are the offloading RSU
    MacNodeId offloadGnbId = nicGrant->getOffloadGnbId();
    if (offloadGnbId != nodeInfo_->getNodeId())
    {
        EV << NOW << " NodePacketController::handleFromUdp - we are not the offloading RSU, drop the NIC grant packet and send a failure feedback to the processing gNB." << endl;
        Packet* fbPacket = new Packet("SrvFD");
        auto srvStatus = makeShared<ServiceStatus>();
        srvStatus->setSuccess(false);
        srvStatus->setAppId(appId);
        srvStatus->setProcessGnbId(nicGrant->getProcessGnbId());
        srvStatus->setOffloadGnbId(nicGrant->getOffloadGnbId());
        fbPacket->insertAtFront(srvStatus);
        socket_.sendTo(fbPacket, Ipv4Address(nicGrant->getProcessGnbAddr()), MEC_NPC_PORT);

        delete pkt;
        pkt = nullptr;
        return;
    }

    int nicInterfaceId = nodeInfo_->getNicInterfaceId();
    EV << "NodePacketController::handleFromUdp - send grant to NIC interface " << nicInterfaceId << endl;
    // find the NIC interface id of the gNodeB
    pkt->clearTags(); // clear all tags first
    int appPort = MacCidToLcid(appId);
    pkt->addTagIfAbsent<InterfaceReq>()->setInterfaceId(nicInterfaceId);
    socket_.sendTo(pkt, Ipv4Address(nicGrant->getUeAddr()), appPort);
}


void NodePacketController::recoverServiceRequests()
{
    // this function is called by other modules (the nodeInfo_), so we need to use
    // Enter_Method or Enter_Method_Silent to tell the simulation kernel "switch context to this module"
    Enter_Method("recoverServiceRequests");

    // resend all buffered service request packets to the global scheduler
    // if (nodeInfo_->getIsGlobalScheduler())
    //     return;

    // if (nodeInfo_->getGlobalSchedulerAddr().isUnspecified())
    //     return;

    if (srvReqsBuffer_.empty())
    {
        EV << NOW << " NodePacketController::recoverServiceRequests - no buffered service request packets to resend." << endl;
        return;
    }

    EV << NOW << " NodePacketController::recoverServiceRequests - check if we need to broadcast any service requests." << endl;
    vector<AppId> toRemove; // remove terminated requests
    for (const auto& pair : nodeInfo_->getNeighborAddrs())
    {
        // check if the neighbor address is reachable
        NetworkInterface* ni = pair.second;
        if (!ni || !ni->isUp() || ni->isWireless())
            continue;

        for (auto it = srvReqsBuffer_.begin(); it != srvReqsBuffer_.end(); ++it)
        {
            AppId appId = it->first;
            Ptr<VecRequest> srvReq = it->second;
            if (srvReq->getStopTime() <= simTime())
            {
                toRemove.push_back(appId);
                continue;
            }
            if (broadcastedSrvReqs_[appId].find(pair.first) != broadcastedSrvReqs_[appId].end())
                continue; // already broadcasted to this neighbor

            Packet* packetToNeighbor = new Packet("SrvReq");
            packetToNeighbor->insertAtBack(srvReqsBuffer_[appId]);
            socket_.sendTo(packetToNeighbor, Ipv4Address(pair.first), MEC_NPC_PORT);
            broadcastedSrvReqs_[appId].insert(pair.first);
        }

        for (auto appId : toRemove)
        {
            srvReqsBuffer_.erase(appId);
            broadcastedSrvReqs_.erase(appId);
        }
        toRemove.clear();
    }
}

